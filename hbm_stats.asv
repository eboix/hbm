n = 200;
a = 3;
b = 1;
c = 1;
d = 1;
cvals = 15;
trials = 1;

res = zeros(    trials);
pdfnames = {};
thresh = c/sqrt(n);
for trialnum = 1:trials
    % n, prob_dist, t, centers, threshold, Q
    obj = hybrid_block_model(n, [1 1], 1, [-d 0; d 0], thresh, [a b; b a]./n);
    [giant_A,giant_mask,giant_rev,A,sparseg] = obj.get_giant_adj_matrix();
    giant_n = length(giant_A);
    
    switch methodname
        case 'nbwalk'
            class = nb_classifier(obj);
        case 'adj'
            class = sym_norm_adj_classifier(obj,giant_A,giant_rev);            
        case 'lap'
            class = lap_classifier(obj,giant_A,giant_rev);
        case 'randwalk'
            class = randwalk_classifier(obj,giant_A,giant_rev);
        case 'sdp'
            sdp_classifier(obj,giant_A,giant_mask);
        case 'high_deg'
            class = high_deg_classifier(obj,giant_A,giant_mask);
        otherwise
            error(sprintf('Method "%s" not found.');
    end
    
    [agreement, perm] = obj.classification_agreement(class);
    agreement = agreement*n/giant_n;
%     if obj.t ~= 0
%         [geo_map_agreement, ~] = obj.classification_agreement_geo_predictor(class);
%         geo_map_agreement = geo_map_agreement*n/giant_n;
%     end
    res(trialnum) = agreement;
end
filename = sprintf('%s_n%d_a%0.2f_b%0.2f_c%0.2f_d%0.2f', methodname, n, a, b, c, d);
save(filename,'res'